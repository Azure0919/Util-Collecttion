1.Redis简介
```
Redis是一个基于BSD开源的项目，是一个把结构化的数据放在内存中的一个存储系统，你可以把它作为数据库，缓存和消息中间件来使用。
同时支持strings，lists，hashes，sets，sorted sets，bitmaps，hyperloglogs和geospatial indexes等数据类型。
它还内建了复制，lua脚本，LRU，事务等功能，
通过redis sentinel实现高可用，通过redis cluster实现了自动分片。以及事务，发布/订阅，自动故障转移等等。
```
2.最基本的缓存使用
```
为API的响应加上基于HTTP的缓存控制,提升响应速度,比如缓存十分钟
但是还有2个弊端：第一个是在缓存生效的10分钟内，api消费者可能会得到旧的数据；
第二个是如果api的客户端无视缓存直接访问API依然是需要2秒，治标不治本呐。
```
3.基于本机内存的缓存
```
即把SQL查询的结果直接缓存在当前api服务器的内存中（设置缓存有效时间为1分钟）。后续1分钟内的请求直接读缓存，不再花费2秒去执行SQL了
于是很快我们就发现API服务器的内存要爆满
```
4.服务端的Redis
```  
在API服务器的内存都被缓存塞满的时候，最直接的想法就是我们把这些缓存都丢到一个专门的服务器上吧，
随后我们就用上了一台单独的服务器作为Redis的服务器，API服务器的内存压力得以解决。
```
5.持久化（Persistence）
```
单台的Redis服务器挂机,导致所有的缓存都丢失了（redis的数据是存储在内存）。虽然可以把Redis服务器重新上线，但是由于内存的数据丢失，造成了缓存雪崩
于是Redis的持久化功能就派上用场，可以缓解一下缓存雪崩带来的影响。
redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。

```
6. 哨兵（Sentinel）和复制（Replication）
``` 
edis服务器毫无征兆的罢工需要复制备份,如何切换备份
这时候就需要Sentinel和Replication出场了。Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能；
Replication则是负责让一个Redis服务器可以配备多个备份的服务器。Redis也是利用这两个功能来保证Redis的高可用的。
Sentinel功能则是对Redis的发布和订阅功能的一个利用。

```
7.集群
```
横向扩展。最终的目的既是把每台服务器只负责其中的一部分，让这些所有的服务器构成一个整体，对外界的消费者而言，
这一组分布式的服务器就像是一个集中式的服务器一样（之前在解读REST的博客中解释过分布式于基于网络的差异：基于网络应用的架构）。
```

8.数据类型
``` 
redis支持丰富的数据类型，从最基础的string到复杂的常用到的数据结构都有支持：

string：最基本的数据类型，二进制安全的字符串，最大512M。
list：按照添加顺序保持顺序的字符串列表。
set：无序的字符串集合，不存在重复的元素。
sorted set：已排序的字符串集合。
hash：key-value对的一种集合。
bitmap：更细化的一种操作，以bit为单位。
hyperloglog：基于概率的数据结构。

```

9.事务
``` 
很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，
即支持一次性按顺序执行多个命令的能力，并保证其原子性。
```

10.Lua脚本
``` 
在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了（比如在获取某一个缓存的时候，同时延长其过期时间）。
redis保证lua脚本的原子性，一定的场景下，是可以代替redis提供的事务相关的命令的。相当于基于网络应用的架构风格中介绍到的远程求值（Remote Evluation = REV）的具体实现。

ngix+lua实现负载均衡
```

11.管道
```
因为redis的客户端和服务器的连接时基于TCP的， 默认每次连接都时只能执行一个命令。管道则是允许利用一次连接来处理多条命令，从而可以节省一些tcp连接的开销。
管道和事务的差异在于管道是为了节省通信的开销，但是并不会保证原子性。
```

12.分布式锁
``` 
官方推荐采用Redlock算法，即使用string类型，加锁的时候给的一个具体的key，然后设置一个随机的值；取消锁的时候用使用lua脚本来先执行获取比较，然后再删除key。具体的命令如下：

SET resource_name my_random_value NX PX 30000

if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
   
```


总结
``` 
1、缓存
缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，
所以，现在Redis用在缓存的场合非常多。

2、排行榜
很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。
Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。

3、计数器
什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。
Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。

4、分布式会话
集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，
session不再由容器管理，而是由session服务及内存数据库管理。

5、分布式锁
在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，
并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，
大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。

6、 社交网络
点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，
Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。

7、最新列表
Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，
无需查询最新的列表，直接根据ID去到对应的内容页即可。

8、消息系统
消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。
Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。
```